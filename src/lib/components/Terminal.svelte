<script lang="ts">
  import { onDestroy, onMount } from 'svelte';
  import '@xterm/xterm/css/xterm.css';
  import { Terminal, type ITheme } from '@xterm/xterm';
  import { FitAddon } from '@xterm/addon-fit';
  import { WebLinksAddon } from '@xterm/addon-web-links';
  import dompurify from 'dompurify';
  import { Marked } from 'marked';
  import { markedHighlight } from 'marked-highlight';
  import { mangle } from 'marked-mangle';
  import markedLinkifyIt from 'marked-linkify-it';
  import markedFootnote from 'marked-footnote';
  import markedAlert from 'marked-alert';
  import tlds from 'tlds';
  import hljs from 'highlight.js';
  import 'highlight.js/styles/atom-one-dark.css';
  import { markedEmoji } from 'marked-emoji';
  import { Octokit } from '@octokit/rest';
  import { createDirectives } from 'marked-directive';
  import markedKatex from 'marked-katex-extension';

  export let files = new Map<string, string>();

  interface Directory {
    [name: string]: Directory | string;
  }

  let pwd = new Array<string>();
  let fileSystem: Directory = {};
  let typedPrompt = '';
  let termElem: HTMLElement;
  let pagerElem: HTMLElement;
  let term: Terminal;
  let fitTermAddon: FitAddon;
  let resizeObserver: ResizeObserver;
  let mutationObserver: MutationObserver;
  let markDownHtml = 'Loading';
  let termThemeDark: ITheme = {
    brightBlack: '#383a42',
    black: '#383a42',
    brightBlue: '#61afef',
    blue: '#61afef',
    brightCyan: '#56b6c2',
    cyan: '#56b6c2',
    brightGreen: '#98c379',
    green: '#98c379',
    brightMagenta: '#c678dd',
    magenta: '#c678dd',
    brightRed: '#e06c75',
    red: '#e06c75',
    brightWhite: '#fafafa',
    white: '#fafafa',
    brightYellow: '#e5c07b',
    yellow: '#e5c07b',
    background: '#282c34',
    foreground: '#abb2bf',
    cursor: '#abb2bf',
    selectionBackground: '#abb2bf',
    selectionForeground: '#282c34',
    cursorAccent: '',
    extendedAnsi: [],
    selectionInactiveBackground: '#abb2bf'
  };
  let termThemeLight: ITheme = {
    brightBlack: '#282c34',
    black: '#282c34',
    brightBlue: '#61afef',
    blue: '#61afef',
    brightCyan: '#56b6c2',
    cyan: '#56b6c2',
    brightGreen: '#98c379',
    green: '#98c379',
    brightMagenta: '#c678dd',
    magenta: '#c678dd',
    brightRed: '#e06c75',
    red: '#e06c75',
    brightWhite: '#abb2bf',
    white: '#abb2bf',
    brightYellow: '#e5c07b',
    yellow: '#e5c07b',
    background: '#fafafa',
    foreground: '#383a42',
    cursor: '#383a42',
    selectionBackground: '#383a42',
    selectionForeground: '#fafafa',
    cursorAccent: '',
    extendedAnsi: [],
    selectionInactiveBackground: '#383a42'
  };

  const marked = new Marked(
    markedHighlight({
      langPrefix: 'hljs language-',
      highlight(code, lang) {
        const language = hljs.getLanguage(lang) ? lang : 'plaintext';
        return hljs.highlight(code, { language }).value;
      }
    })
  );
  marked.setOptions({
    async: true,
    breaks: true,
    gfm: true
  });
  marked.use(
    markedLinkifyIt(
      {},
      {
        fuzzyIP: true,
        fuzzyEmail: true,
        fuzzyLink: true,
        tlds: tlds,
        tldsKeepOld: true
      }
    )
  );
  marked.use(markedFootnote());
  marked.use(mangle());
  marked.use(markedAlert());
  marked.use(createDirectives());
  marked.use(
    markedKatex({
      throwOnError: false
    })
  );

  let prompt = (): string => {
    const dir = pwd.join('/');
    if (dir !== '') {
      return (
        '\x1b[1;32m' +
        'pentest' +
        '\x1b[0m' +
        '\x1b[1;31m' +
        '@\x1b[0m' +
        '\x1b[34m' +
        'bi0s' +
        '\x1b[0m' +
        '\x1b[1;31m' +
        '~/' +
        pwd.join('/') +
        '$' +
        '\x1b[0m' +
        ' '
      );
    }
    return (
      '\x1b[1;32m' +
      'pentest' +
      '\x1b[0m' +
      '\x1b[1;31m' +
      '@\x1b[0m' +
      '\x1b[34m' +
      'bi0s' +
      '\x1b[0m' +
      '\x1b[1;31m' +
      '~' +
      '$' +
      '\x1b[0m' +
      ' '
    );
  };

  onMount(async () => {
    marked.use(
      markedEmoji({
        emojis: (await new Octokit().rest.emojis.get()).data,
        unicode: false
      })
    );

    for (const [key, value] of files.entries()) {
      let paths = new Array<string>();
      if (key[0] == '') {
        paths = key.slice(1).trim().split('/');
      } else {
        paths = key.trim().split('/');
      }
      if (paths[0] == 'static') {
        continue;
      }
      let temp = fileSystem;
      for (let i = 0; i < paths.length - 1; i++) {
        if (temp[paths[i]]) {
          temp = temp[paths[i]] as Directory;
          continue;
        }
        temp[paths[i]] = {};
        temp = temp[paths[i]] as Directory;
      }
      temp[paths[paths.length - 1]] = value;
    }

    const font = new FontFace('Roboto Mono', 'url("/fonts/roboto.woff2")');
    document.fonts.add(font);
    await font.load();

    term = new Terminal({
      allowTransparency: true,
      scrollOnUserInput: true,
      fontFamily: 'Roboto Mono',
      fontSize: 14,
      theme: termThemeDark
    });

    if (document.body.classList.contains('light')) {
      term.options.theme = termThemeLight;
    }

    fitTermAddon = new FitAddon();
    term.loadAddon(fitTermAddon);
    term.loadAddon(new WebLinksAddon());
    term.open(termElem);

    term.writeln(
      '\x1b[1;35m' +
        'Type `help` to get a list of commands you can run on this terminal.' +
        '\x1b[0m'
    );
    term.write(prompt());

    fitTermAddon.fit();

    term.onData(async (e) => {
      if (pagerElem.style.display == 'block') {
        if (e == 'q' || e == 'Q') {
          pagerElem.style.display = 'none';
          markDownHtml = 'Loading';
          return;
        }
        if (e == 'j' || e == 'J') {
          pagerElem.scrollBy({
            top: 50,
            left: 0,
            behavior: 'smooth'
          });
          return;
        }
        if (e == 'k' || e == 'K') {
          pagerElem.scrollBy({
            top: -50,
            left: 0,
            behavior: 'smooth'
          });
          return;
        }
        return;
      }
      if (e == '\r') {
        const cmds = typedPrompt.split(' ');
        let pwdContents = fileSystem;
        for (const p of pwd.values()) {
          pwdContents = pwdContents[p] as Directory;
        }
        term.writeln('');
        try {
          switch (cmds[0]) {
            case '':
              break;
            case 'clear':
              term.clear();
              term.write('\x1b[2J');
              term.write('\x1b[H');
              break;
            case 'ls': {
              for (const [key, value] of Object.entries(pwdContents)) {
                if (typeof value === 'string') {
                  term.writeln(key);
                  continue;
                }
                term.writeln(key + '/');
              }
              break;
            }
            case 'pwd': {
              const p = pwd.join('/');
              if (p === '') {
                term.writeln('~');
                break;
              }
              term.writeln('~/' + p);
              break;
            }
            case 'cd': {
              if (cmds.length === 1) {
                pwd = new Array<string>();
                break;
              }
              const paths = cmds[1].split('/');
              for (const path of paths.values()) {
                if (path == '..') {
                  pwd.pop();
                  continue;
                }
                let temp = fileSystem;
                for (const p of pwd.values()) {
                  temp = temp[p] as Directory;
                }
                if (temp[path] && typeof temp[path] !== 'string') {
                  pwd.push(path);
                  continue;
                }
                throw new Error("The directory '" + path + "' does not exist");
              }
              break;
            }
            case 'less': {
              const file = cmds[1];
              if (pwdContents[file]) {
                if (typeof pwdContents[file] === 'string') {
                  pagerElem.style.display = 'block';
                  markDownHtml = 'Loading';
                  markDownHtml = dompurify.sanitize(
                    await marked.parse(await (await fetch(pwdContents[file] as string)).text())
                  ) as string;
                  break;
                }
                throw new Error(file + ' is a directory');
              }
              throw new Error('No such file or directory');
            }
            case 'help':
              term.writeln(
                [
                  'help: prints out all commands you can try out',
                  'ls: Lists out files and directories of the present working directory',
                  'pwd: Prints out the present working directory',
                  'cd: Used to change or navigate through directories',
                  'clear: Clear terminal screen',
                  'less: Pager to view files'
                ].join('\r\n')
              );
              break;
            default:
              throw new Error('command not found');
          }
        } catch (err) {
          term.writeln(cmds[0] + ': ' + (err as Error).message);
        }
        typedPrompt = '';
        term.write(prompt());
      } else if (e == '\t') {
        // TODO: Write autocomplete here.
      } else if (e == '\u007F') {
        if (typedPrompt.length > 0) {
          typedPrompt = typedPrompt.slice(0, -1);
          term.write('\b \b');
        }
      } else {
        if (e.charCodeAt(0) > 31 && e.charCodeAt(0) < 127) {
          typedPrompt += e;
          term.write(e);
        }
      }
    });

    resizeObserver = new ResizeObserver(() => {
      fitTermAddon.fit();
    });
    resizeObserver.observe(termElem);

    mutationObserver = new MutationObserver((mutationList) => {
      for (const mutation of mutationList) {
        if (mutation.type == 'attributes') {
          if (document.body.classList.contains('light')) {
            term.options.theme = termThemeLight;
          } else {
            term.options.theme = termThemeDark;
          }
        }
      }
    });
    mutationObserver.observe(document.body, {
      attributes: true
    });
    term.focus();
  });

  onDestroy(() => {
    resizeObserver.unobserve(termElem);
    resizeObserver.disconnect();
    mutationObserver.disconnect();
  });
</script>

<div class="terminal" bind:this={termElem} on:blur={() => term.focus()}></div>
<div
  class="pager"
  bind:this={pagerElem}
  on:focus={() => term.focus()}
  on:scrollend={() => term.focus()}
  on:scroll={() => term.focus()}
  on:click={() => term.focus()}
  on:dblclick={() => term.focus()}
  on:select={() => term.focus()}
>
  {@html markDownHtml}
</div>

<style>
  .terminal {
    position: fixed;
    top: 55px;
    bottom: 55px;
    left: 15px;
    right: 15px;
  }

  .pager {
    display: none;
    position: fixed;
    top: 55px;
    bottom: 55px;
    left: 15px;
    right: 15px;
    z-index: 99;
    overflow: auto;
    padding-right: 20px;
    padding-left: 20px;
    background-color: var(--color-dark-background);
    color: var(--color-dark-foreground);
  }

  :global(body.light) .pager {
    background-color: var(--color-light-background);
    color: var(--color-light-foreground);
  }

  :global(pre) {
    border-radius: 5px;
    border: 2px solid var(--color-dark-foreground);
    padding: 15px;
    overflow: auto;
  }

  :global(body.light) :global(pre) {
    border: 2px solid var(--color-light-foreground);
  }

  :global(pre) > :global(code.hljs) {
    padding: 0px;
  }

  :global(code.hljs) {
    background-color: var(--color-dark-background);
    color: var(--color-dark-foreground);
  }

  :global(body.light) :global(code.hljs) {
    background-color: var(--color-light-background);
    color: var(--color-light-foreground);
  }

  :global(table) {
    border: 1px solid var(--color-dark-foreground);
    padding: 0px;
    border-spacing: 0px;
  }

  :global(body.light) :global(table) {
    border: 1px solid var(--color-light-foreground);
  }

  :global(td) {
    border: 1px solid var(--color-dark-foreground);
    padding: 5px;
  }

  :global(body.light) :global(td) {
    border: 1px solid var(--color-light-foreground);
  }

  :global(th) {
    border: 1px solid var(--color-dark-foreground);
    padding: 5px;
  }

  :global(body.light) :global(th) {
    border: 1px solid var(--color-light-foreground);
  }

  :global(div.markdown-alert > p.markdown-alert-title) {
    display: flex;
    align-items: center;
  }

  :global(div.markdown-alert > p.markdown-alert-title > svg.octicon) {
    margin-right: 5px;
  }

  :global(div.markdown-alert) {
    border-left: 5px solid var(--color-dark-foreground);
    margin-left: 0px;
    padding-left: 10px;
  }

  :global(body.light) :global(.markdown-alert) {
    border-left: 5px solid var(--color-light-foreground);
  }

  :global(div.markdown-alert.markdown-alert-caution) {
    border-left: 5px solid var(--color-red);
  }

  :global(div.markdown-alert.markdown-alert-important) {
    border-left: 5px solid var(--color-magenta);
  }

  :global(div.markdown-alert.markdown-alert-tip) {
    border-left: 5px solid var(--color-green);
  }

  :global(div.markdown-alert.markdown-alert-note) {
    border-left: 5px solid var(--color-blue);
  }

  :global(div.markdown-alert.markdown-alert-warning) {
    border-left: 5px solid var(--color-yellow);
  }

  :global(div.markdown-alert-caution > p.markdown-alert-title) {
    color: var(--color-red);
    fill: var(--color-red);
  }

  :global(div.markdown-alert-important > p.markdown-alert-title) {
    color: var(--color-magenta);
    fill: var(--color-magenta);
  }

  :global(div.markdown-alert-tip > p.markdown-alert-title) {
    color: var(--color-green);
    fill: var(--color-green);
  }

  :global(div.markdown-alert-note > p.markdown-alert-title) {
    color: var(--color-blue);
    fill: var(--color-blue);
  }

  :global(div.markdown-alert-warning > p.markdown-alert-title) {
    color: var(--color-yellow);
    fill: var(--color-yellow);
  }

  :global(blockquote) {
    border-left: 5px solid var(--color-dark-foreground);
    margin-left: 0px;
    padding-left: 10px;
  }

  :global(body.light) :global(blockquote) {
    border-left: 5px solid var(--color-light-foreground);
  }
</style>
