<script lang="ts">
  import { onDestroy, onMount } from 'svelte';
  import '@xterm/xterm/css/xterm.css';
  import { Terminal, type ITheme } from '@xterm/xterm';
  import { FitAddon } from '@xterm/addon-fit';
  import { WebLinksAddon } from '@xterm/addon-web-links';
  import dompurify from 'dompurify';
  import { Marked } from 'marked';
  import { markedHighlight } from 'marked-highlight';
  import { mangle } from 'marked-mangle';
  import markedLinkifyIt from 'marked-linkify-it';
  import tlds from 'tlds';
  import hljs from 'highlight.js';
  import 'highlight.js/styles/atom-one-dark.css';
  // import 'highlight.js/styles/atom-one-light.css';

  export let files = new Map<string, string>();

  interface Directory {
    [name: string]: Directory | string;
  }

  let pwd = new Array<string>();
  let fileSystem: Directory = {};
  let typedPrompt = '';
  let termElem: HTMLElement;
  let pagerElem: HTMLElement;
  let term: Terminal;
  let fitTermAddon: FitAddon;
  let resizeObserver: ResizeObserver;
  let mutationObserver: MutationObserver;
  let termThemeDark: ITheme = {
    brightBlack: '#383a42',
    black: '#383a42',
    brightBlue: '#61afef',
    blue: '#61afef',
    brightCyan: '#56b6c2',
    cyan: '#56b6c2',
    brightGreen: '#98c379',
    green: '#98c379',
    brightMagenta: '#c678dd',
    magenta: '#c678dd',
    brightRed: '#e06c75',
    red: '#e06c75',
    brightWhite: '#fafafa',
    white: '#fafafa',
    brightYellow: '#e5c07b',
    yellow: '#e5c07b',
    background: '#282c34',
    foreground: '#abb2bf',
    cursor: '#abb2bf',
    selectionBackground: '#abb2bf',
    selectionForeground: '#282c34',
    cursorAccent: '',
    extendedAnsi: [],
    selectionInactiveBackground: '#abb2bf'
  };
  let termThemeLight: ITheme = {
    brightBlack: '#282c34',
    black: '#282c34',
    brightBlue: '#61afef',
    blue: '#61afef',
    brightCyan: '#56b6c2',
    cyan: '#56b6c2',
    brightGreen: '#98c379',
    green: '#98c379',
    brightMagenta: '#c678dd',
    magenta: '#c678dd',
    brightRed: '#e06c75',
    red: '#e06c75',
    brightWhite: '#abb2bf',
    white: '#abb2bf',
    brightYellow: '#e5c07b',
    yellow: '#e5c07b',
    background: '#fafafa',
    foreground: '#383a42',
    cursor: '#383a42',
    selectionBackground: '#383a42',
    selectionForeground: '#fafafa',
    cursorAccent: '',
    extendedAnsi: [],
    selectionInactiveBackground: '#383a42'
  };

  const marked = new Marked(
    markedHighlight({
      langPrefix: 'hljs language-',
      highlight(code, lang) {
        const language = hljs.getLanguage(lang) ? lang : 'plaintext';
        return hljs.highlight(code, { language }).value;
      }
    })
  );
  marked.use({
    async: true,
    breaks: true,
    gfm: true
  });
  marked.use(
    markedLinkifyIt(
      {},
      {
        fuzzyIP: true,
        fuzzyEmail: true,
        fuzzyLink: true,
        tlds: tlds,
        tldsKeepOld: true
      }
    )
  );
  marked.use(mangle());

  let prompt = (): string => {
    const dir = pwd.join('/');
    if (dir !== '') {
      return (
        '\x1b[1;32m' +
        'pentest' +
        '\x1b[0m' +
        '\x1b[1;31m' +
        '@\x1b[0m' +
        '\x1b[34m' +
        'bi0s' +
        '\x1b[0m' +
        '\x1b[1;31m' +
        '~/' +
        pwd.join('/') +
        '$' +
        '\x1b[0m' +
        ' '
      );
    }
    return (
      '\x1b[1;32m' +
      'pentest' +
      '\x1b[0m' +
      '\x1b[1;31m' +
      '@\x1b[0m' +
      '\x1b[34m' +
      'bi0s' +
      '\x1b[0m' +
      '\x1b[1;31m' +
      '~' +
      '$' +
      '\x1b[0m' +
      ' '
    );
  };
  // TODO: Get the key listeners working on pager.
  let pagerKeyListener = (e: KeyboardEvent) => {
    console.log(e.key);
    if (e.key == 'q' || e.key == 'Q') {
      pagerElem.style.display = 'none';
      termElem.style.display = 'block';
      termElem.focus();
      term.focus();
      return;
    }
    if (e.key == 'j' || e.key == 'J') {
      pagerElem.scrollBy({
        top: 10,
        left: 0,
        behavior: 'smooth'
      });
      return;
    }
    if (e.key == 'k' || e.key == 'K') {
      pagerElem.scrollBy({
        top: -10,
        left: 0,
        behavior: 'smooth'
      });
      return;
    }
  };

  onMount(async () => {
    for (const [key, value] of files.entries()) {
      let paths = new Array<string>();
      if (key[0] == '') {
        paths = key.slice(1).trim().split('/');
      } else {
        paths = key.trim().split('/');
      }
      if (paths[0] == 'static') {
        continue;
      }
      let temp = fileSystem;
      for (let i = 0; i < paths.length - 1; i++) {
        if (temp[paths[i]]) {
          temp = temp[paths[i]] as Directory;
          continue;
        }
        temp[paths[i]] = {};
        temp = temp[paths[i]] as Directory;
      }
      temp[paths[paths.length - 1]] = value;
    }

    const font = new FontFace('Roboto Mono', 'url("/fonts/roboto.woff2")');
    document.fonts.add(font);
    await font.load();

    term = new Terminal({
      allowTransparency: true,
      scrollOnUserInput: true,
      fontFamily: 'Roboto Mono',
      fontSize: 14,
      theme: termThemeDark
    });

    if (document.body.classList.contains('light')) {
      term.options.theme = termThemeLight;
    }

    fitTermAddon = new FitAddon();
    term.loadAddon(fitTermAddon);
    term.loadAddon(new WebLinksAddon());
    term.open(termElem);

    term.writeln(
      '\x1b[1;35m' +
        'Type `help` to get a list of commands you can run on this terminal.' +
        '\x1b[0m'
    );
    term.write(prompt());

    fitTermAddon.fit();

    // TODO: Implement all commands and pager element functionality.
    term.onData(async (e) => {
      if (e == '\r') {
        const cmds = typedPrompt.split(' ');
        let pwdContents = fileSystem;
        for (const p of pwd.values()) {
          pwdContents = pwdContents[p] as Directory;
        }
        term.writeln('');
        try {
          switch (cmds[0]) {
            case '':
              break;
            case 'clear':
              term.clear();
              term.write('\x1b[2J');
              term.write('\x1b[H');
              break;
            case 'ls': {
              for (const [key, value] of Object.entries(pwdContents)) {
                if (typeof value === 'string') {
                  term.writeln(key);
                  continue;
                }
                term.writeln(key + '/');
              }
              break;
            }
            case 'pwd': {
              const p = pwd.join('/');
              if (p === '') {
                term.writeln('~');
                break;
              }
              term.writeln('~/' + p);
              break;
            }
            case 'cd': {
              if (cmds.length === 1) {
                pwd = new Array<string>();
                break;
              }
              const paths = cmds[1].split('/');
              for (const path of paths.values()) {
                if (path == '..') {
                  pwd.pop();
                  continue;
                }
                let temp = fileSystem;
                for (const p of pwd.values()) {
                  temp = temp[p] as Directory;
                }
                if (temp[path] && typeof temp[path] !== 'string') {
                  pwd.push(path);
                  continue;
                }
                throw new Error("The directory '" + path + "' does not exist");
              }
              break;
            }
            case 'less': {
              const file = cmds[1];
              if (pwdContents[file]) {
                if (typeof pwdContents[file] === 'string') {
                  pagerElem.style.display = 'block';
                  pagerElem.focus();
                  termElem.style.display = 'none';
                  const data: string = await (await fetch(pwdContents[file] as string)).text();
                  pagerElem.innerHTML = dompurify.sanitize(await marked.parse(data)) as string;
                  break;
                }
                throw new Error(file + ' is a directory');
              }
              throw new Error('No such file or directory');
            }
            case 'help':
              term.writeln(
                [
                  'help: prints out all commands you can try out',
                  'ls: Lists out files and directories of the present working directory',
                  'pwd: Prints out the present working directory',
                  'cd: Used to change or navigate through directories',
                  'clear: Clear terminal screen',
                  'less: Pager to view files',
                  'find: Used to find files',
                  'grep: Used to search for content'
                ].join('\r\n')
              );
              break;
            default:
              throw new Error('command not found');
          }
        } catch (err) {
          term.writeln(cmds[0] + ': ' + (err as Error).message);
        }
        typedPrompt = '';
        term.write(prompt());
      } else if (e == '\t') {
        // TODO: Write autocomplete here.
      } else if (e == '\u007F') {
        if (typedPrompt.length > 0) {
          typedPrompt = typedPrompt.slice(0, -1);
          term.write('\b \b');
        }
      } else {
        typedPrompt += e;
        term.write(e);
      }
    });

    resizeObserver = new ResizeObserver(() => {
      fitTermAddon.fit();
    });
    resizeObserver.observe(termElem);

    mutationObserver = new MutationObserver((mutationList) => {
      for (const mutation of mutationList) {
        if (mutation.type == 'attributes') {
          if (document.body.classList.contains('light')) {
            term.options.theme = termThemeLight;
          } else {
            term.options.theme = termThemeDark;
          }
        }
      }
    });
    mutationObserver.observe(document.body, {
      attributes: true
    });
  });

  onDestroy(() => {
    resizeObserver.unobserve(termElem);
    resizeObserver.disconnect();
    mutationObserver.disconnect();
  });
</script>

<div class="terminal" bind:this={termElem}></div>
<div class="pager" on:keydown={pagerKeyListener} bind:this={pagerElem}></div>

<style>
  .terminal {
    position: fixed;
    top: 55px;
    bottom: 55px;
    left: 15px;
    right: 15px;
  }

  .pager {
    display: none;
    position: fixed;
    top: 55px;
    bottom: 55px;
    left: 15px;
    right: 15px;
    z-index: 99;
    overflow: auto;
    padding-right: 5px;
    background-color: var(--color-dark-background);
    color: var(--color-dark-foreground);
  }

  :global(body.light) .pager {
    background-color: var(--color-light-background);
    color: var(--color-light-foreground);
  }

  :global(.hljs) {
    background-color: var(--color-dark-background);
    color: var(--color-dark-foreground);
  }

  :global(body.light) :global(.hljs) {
    background-color: var(--color-light-background);
    color: var(--color-light-foreground);
  }
</style>
