<script lang="ts">
  import { onDestroy, onMount } from 'svelte';
  import 'xterm/css/xterm.css';
  import { Terminal, type ITheme } from '@xterm/xterm';
  import { FitAddon } from '@xterm/addon-fit';
  import { WebLinksAddon } from '@xterm/addon-web-links';

  export let files = new Map<string, string>();

  interface Directory {
    [name: string]: Directory | string;
  }

  let pwd = new Array<string>();
  let fileSystem: Directory = {};
  let typedPrompt = '';
  let termElem: HTMLElement;
  let term: Terminal;
  let fitTermAddon: FitAddon;
  let resizeObserver: ResizeObserver;
  let mutationObserver: MutationObserver;
  let termThemeDark: ITheme = {
    brightBlack: '#383a42',
    black: '#383a42',
    brightBlue: '#61afef',
    blue: '#61afef',
    brightCyan: '#56b6c2',
    cyan: '#56b6c2',
    brightGreen: '#98c379',
    green: '#98c379',
    brightMagenta: '#c678dd',
    magenta: '#c678dd',
    brightRed: '#e06c75',
    red: '#e06c75',
    brightWhite: '#fafafa',
    white: '#fafafa',
    brightYellow: '#e5c07b',
    yellow: '#e5c07b',
    background: '#282c34',
    foreground: '#abb2bf',
    cursor: '#abb2bf',
    selectionBackground: '#abb2bf',
    selectionForeground: '#282c34',
    cursorAccent: '',
    extendedAnsi: [],
    selectionInactiveBackground: '#abb2bf'
  };
  let termThemeLight: ITheme = {
    brightBlack: '#282c34',
    black: '#282c34',
    brightBlue: '#61afef',
    blue: '#61afef',
    brightCyan: '#56b6c2',
    cyan: '#56b6c2',
    brightGreen: '#98c379',
    green: '#98c379',
    brightMagenta: '#c678dd',
    magenta: '#c678dd',
    brightRed: '#e06c75',
    red: '#e06c75',
    brightWhite: '#abb2bf',
    white: '#abb2bf',
    brightYellow: '#e5c07b',
    yellow: '#e5c07b',
    background: '#fafafa',
    foreground: '#383a42',
    cursor: '#383a42',
    selectionBackground: '#383a42',
    selectionForeground: '#fafafa',
    cursorAccent: '',
    extendedAnsi: [],
    selectionInactiveBackground: '#383a42'
  };
  let prompt = (): string => {
    const dir = pwd.join('/');
    if (dir !== '') {
      return (
        '\x1b[1;32m' +
        'pentest' +
        '\x1b[0m' +
        '\x1b[1;31m' +
        '@\x1b[0m' +
        '\x1b[34m' +
        'bi0s' +
        '\x1b[0m' +
        '\x1b[1;31m' +
        '~/' +
        pwd.join('/') +
        '$' +
        '\x1b[0m' +
        ' '
      );
    }
    return (
      '\x1b[1;32m' +
      'pentest' +
      '\x1b[0m' +
      '\x1b[1;31m' +
      '@\x1b[0m' +
      '\x1b[34m' +
      'bi0s' +
      '\x1b[0m' +
      '\x1b[1;31m' +
      '~' +
      '$' +
      '\x1b[0m' +
      ' '
    );
  };

  onMount(async () => {
    for (const [key, value] of files.entries()) {
      let paths = new Array<string>();
      if (key[0] == '') {
        paths = key.slice(1).trim().split('/');
      } else {
        paths = key.trim().split('/');
      }
      if (paths[0] == 'static') {
        continue;
      }
      let temp = fileSystem;
      for (let i = 0; i < paths.length - 1; i++) {
        if (temp[paths[i]]) {
          temp = temp[paths[i]] as Directory;
          continue;
        }
        temp[paths[i]] = {};
        temp = temp[paths[i]] as Directory;
      }
      temp[paths[paths.length - 1]] = value;
    }

    const font = new FontFace('Roboto Mono', 'url("/fonts/roboto.woff2")');
    document.fonts.add(font);
    await font.load();

    term = new Terminal({
      allowTransparency: true,
      scrollOnUserInput: true,
      fontFamily: 'Roboto Mono',
      fontSize: 15,
      theme: termThemeDark
    });

    if (document.body.classList.contains('light')) {
      term.options.theme = termThemeLight;
    }

    fitTermAddon = new FitAddon();
    term.loadAddon(fitTermAddon);
    term.loadAddon(new WebLinksAddon());
    term.open(termElem);

    term.writeln(
      '\x1b[1;35m' +
        'Type `help` to get a list of commands you can run on this terminal.' +
        '\x1b[0m'
    );
    term.write(prompt());

    fitTermAddon.fit();

    // TODO: Implement all commands and pager element functionality.
    term.onData((e) => {
      if (e == '\r') {
        const cmds = typedPrompt.split(' ');
        term.writeln('');
        try {
          switch (cmds[0]) {
            case '':
              break;
            case 'ls': {
              let temp = fileSystem;
              for (const p of pwd.values()) {
                temp = temp[p] as Directory;
              }
              for (const [key, value] of Object.entries(temp)) {
                if (typeof value === 'string') {
                  term.writeln(key);
                  continue;
                }
                term.writeln(key + '/');
              }
              break;
            }
            case 'pwd': {
              const p = pwd.join('/');
              if (p === '') {
                term.writeln('~');
                break;
              }
              term.writeln('~/' + p);
              break;
            }
            case 'cd': {
              if (cmds.length === 1) {
                pwd = new Array<string>();
                break;
              }
              const paths = cmds[1].split('/');
              for (const path of paths.values()) {
                if (path == '..') {
                  pwd.pop();
                  continue;
                }
                let temp = fileSystem;
                for (const p of pwd.values()) {
                  temp = temp[p] as Directory;
                }
                if (temp[path] && typeof temp[path] !== 'string') {
                  pwd.push(path);
                  continue;
                }
                throw new Error("The directory '" + path + "' does not exist");
              }
              break;
            }
            case 'help':
              term.writeln(
                [
                  'help: prints out all commands you can try out',
                  'ls: Lists out files and directories of the present working directory',
                  'pwd: Prints out the present working directory',
                  'cd: Used to change or navigate through directories',
                  'less: Pager to view files',
                  'find: Used to find files',
                  'grep: Used to search for content'
                ].join('\r\n')
              );
              break;
            default:
              throw new Error('command not found');
          }
        } catch (err) {
          term.writeln(cmds[0] + ': ' + (err as Error).message);
        }
        typedPrompt = '';
        term.write(prompt());
      } else if (e == '\t') {
        // TODO: Right autocomplete here.
      } else if (e == '\u007F') {
        if (typedPrompt.length > 0) {
          typedPrompt = typedPrompt.slice(0, -1);
          term.write('\b \b');
        }
      } else {
        typedPrompt += e;
        term.write(e);
      }
    });

    resizeObserver = new ResizeObserver(() => {
      fitTermAddon.fit();
    });
    resizeObserver.observe(termElem);

    mutationObserver = new MutationObserver((mutationList) => {
      for (const mutation of mutationList) {
        if (mutation.type == 'attributes') {
          if (document.body.classList.contains('light')) {
            term.options.theme = termThemeLight;
          } else {
            term.options.theme = termThemeDark;
          }
        }
      }
    });
    mutationObserver.observe(document.body, {
      attributes: true
    });
  });

  onDestroy(() => {
    resizeObserver.unobserve(termElem);
    resizeObserver.disconnect();
    mutationObserver.disconnect();
  });
</script>

<div class="terminal" bind:this={termElem}></div>

<style>
  .terminal {
    position: fixed;
    top: 55px;
    bottom: 55px;
    left: 15px;
    right: 15px;
  }
</style>
